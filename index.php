<?php
require 'common/function.php';

if (dirname($_SERVER['SCRIPT_FILENAME']) != 'DesignPatterns') {
    chdir('DesignPatterns');
}




#=========================== 创建型模式 =======================#
## 为需要的类创建对象而生
# - [单例模式]
# - [工厂模式]
# - [抽象工厂模式]
# - [原型模式]
# - [建造者模式]

## - [单例模式]
// require 'Singleton.php';

## - [工厂模式]
/**
 * 工厂方法模式和抽象工厂模式的核心区别
 * 工厂方法模式利用继承,抽象工厂模式利用组合
 * 工厂方法模式产生一个对象,抽象工厂模式产生一族对象
 * 工厂方法模式利用子类创造对象,抽象工厂模式利用接口的实现创造对象
 * 工厂方法模式可以退化为简单工厂模式(非23中GOF)
 */
// require 'Factory.php';


## - [抽象工厂模式]
/* 
* 说说我理解的工厂模式和抽象工厂模式的区别：
* 工厂就是一个独立公司,负责生产对象；
* 抽象工厂就是集团,负责生产子公司（工厂）；
*/
// 适用于更大型设计,比如框架
// 模拟调用, 抽象工厂模式核心是面向接口编程
// require 'AbstractFactory.php';


## - [原型模式]
/**
 * php原型模式
 * 用于创建对象成本过高时
 */
// require 'Prototype.php';

## [建造者模式]
/**
 * php建造者模式
 * 简单对象构建复杂对象
 * 基本组件不变,但是组件之间的组合方式善变
 */
// require 'Builder.php';


#================================= 结构型模式实例 =================================# 
## 结构上使用到了别的类的结构
# - [桥接模式]
# - [享元模式]

## - [桥接模式]
/*
* php桥接模式
* 基础的结构型设计模式：将抽象和实现解耦,对抽象的实现是实体行为对接口的实现
* 例如：人 => 抽象为属性：性别 动作：吃 => 人吃的动作抽象为interface => 实现不同的吃法
*/
// require 'Bridge.php';

## - [享元模式]
/* 
* php享元（轻量级）模式
* 就是缓存了创建型模式创建的对象,不知道为什么会归在结构型模式中,个人觉得创建型模式更合适,哈哈～
* 其次,享元强调的缓存对象,外观模式强调的对外保持简单易用,是不是就大体构成了目前牛逼哄哄且满大
* 的街【依赖注入容器】
*/
// require 'FlyWeight.php';

## - [门面模式]
/*
* php外观模式
* 把系统中类的调用委托给一个单独的类,对外隐藏了内部的复杂性,很有依赖注入容器的感觉哦
*/
// require 'Facade.php';

## - [适配器模式]
/*
 * php适配器模式
 * 把实现了不同接口的对象通过适配器的方式组合起来放在一个新的环境
 */
// require 'Adapter.php';

## - [装饰器模式]
/*
 * 对现有的对象增加功能
 * 和适配器的区别：适配器是连接两个接口,装饰器是对现有的对象包装
 */
// require 'Decorator.php';

## - [组合模式]
/*
* php组合（部分整体）模式
* 定义：将对象以树形结构组织起来,以达成“部分－整体”的层次结构,使得客户端对单个对象和组合对象的使用具有一致性
* 我的理解：把对象构建成树形结构
*/
require 'Composite.php';
