<?php
/*

pcntl_fork()函数是php-pcntl模块中用于创建进程的函数。（不支持windows）

1.$one = 123;
2.$one++;
3.$two = time();
4.$pid = [];
5.$pid = pcntl_fork();
6.$three = time();


当：pcntl_fork()函数执行的时候，会创建一个子进程。子进程会复制当前进程，也就是父进程的所有：数据，代码，还有状态。
1.当pcntl_fork（）创建子进程成功后，在父进程内，返回0，在子进程内返回自身的进程号，失败则返回-1
2.子进程会复制父进程的代码，数据。那么就说明：子，父进程拥有的代码和数据会一模一样。
3.重点：子进程会复制父进程的状态，那么就有上面的示例代码：在第五行执行了pcntl_fork，那么创建出的子进程，代码也是从第五行开始执行的。又子进程复制了数据，代码。所以，在子进程内同理存在：$one,$two等变量


for ($i = 0; $i < 3; $i++) {
    $pid = pcntl_fork();
}
sleep(30);

那么：上面的for循环，实际会产生多少个子进程？答案是7个，在linux下，用ps命令将可以看到8个进程（1个父进程，7个子进程）
原因：父进程在$i=0时，创建出一个子进程0，此时的子进程，还会继续执行循环。创建出属于自己的子进程。同理：$i=1时也会这样……

执行解析：
父进程($i=0)
    执行fork子进程A1($i=1)
        执行fork子进程B1($i=2)
            执行fork子进程($i=3)
        执行fork子进程B2($i=2)
            执行fork子进程($i=3)
    执行fork子进程B1($i=2)
            执行fork子进程($i=3)


PS：最需要注意的是fork的子进程是继承状态

*/
echo '====================';
for ($i = 0; $i < 3; $i++) {
    echo '当前循环：' . $i;
    echo '====================' . PHP_EOL;
    echo '当前pid：' . posix_getpid() . PHP_EOL;
    echo '====================';
    $pid = pcntl_fork();
}
// sleep(30);
